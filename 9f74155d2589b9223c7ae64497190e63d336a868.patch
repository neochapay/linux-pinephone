From 9f74155d2589b9223c7ae64497190e63d336a868 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Philip=20M=C3=BCller?= <philm@manjaro.org>
Date: Sun, 3 Oct 2021 13:10:19 +0200
Subject: [PATCH] [pkg-upd] 5.14.9-5 - add patches from
 https://invent.kde.org/teams/plasma-mobile/issues/-/issues/3

---
 ...rivers-usb-add-reset_resume-callback.patch | 24 +++++++
 ...s-Add-USB_QUIRK_RESET-for-Quectel-EG.patch | 28 ++++++++
 ...wan-provide-wrapper-for-reset_resume.patch | 51 +++++++++++++++
 ...wdm-provide-wrapper-for-reset_resume.patch | 65 +++++++++++++++++++
 ...b-qmi_wwan-set-the-DTR-when-resuming.patch | 34 ++++++++++
 ...cdc-wdm-send-HUP-if-we-are-resetting.patch | 27 ++++++++
 PKGBUILD                                      | 15 ++++-
 7 files changed, 242 insertions(+), 2 deletions(-)
 create mode 100644 0001-drivers-usb-add-reset_resume-callback.patch
 create mode 100644 0002-Revert-usb-quirks-Add-USB_QUIRK_RESET-for-Quectel-EG.patch
 create mode 100644 0003-qmi_wwan-provide-wrapper-for-reset_resume.patch
 create mode 100644 0004-cdc-wdm-provide-wrapper-for-reset_resume.patch
 create mode 100644 0005-net-usb-qmi_wwan-set-the-DTR-when-resuming.patch
 create mode 100644 0006-cdc-wdm-send-HUP-if-we-are-resetting.patch

diff --git a/0001-drivers-usb-add-reset_resume-callback.patch b/0001-drivers-usb-add-reset_resume-callback.patch
new file mode 100644
index 0000000..c232f58
--- /dev/null
+++ b/0001-drivers-usb-add-reset_resume-callback.patch
@@ -0,0 +1,24 @@
+From 22008251d617054271a65f29178e2df74dd3e33c Mon Sep 17 00:00:00 2001
+From: Bhushan Shah <bshah@kde.org>
+Date: Fri, 9 Apr 2021 16:22:49 +0530
+Subject: [PATCH 1/5] drivers/usb: add reset_resume callback
+
+---
+ drivers/usb/serial/option.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c
+index c6969ca728390..21aeb7dc8f6ee 100644
+--- a/drivers/usb/serial/option.c
++++ b/drivers/usb/serial/option.c
+@@ -2105,6 +2105,7 @@ static struct usb_serial_driver option_1port_device = {
+ #ifdef CONFIG_PM
+ 	.suspend           = usb_wwan_suspend,
+ 	.resume            = usb_wwan_resume,
++	.reset_resume      = usb_wwan_resume,
+ #endif
+ };
+ 
+-- 
+2.31.1
+
diff --git a/0002-Revert-usb-quirks-Add-USB_QUIRK_RESET-for-Quectel-EG.patch b/0002-Revert-usb-quirks-Add-USB_QUIRK_RESET-for-Quectel-EG.patch
new file mode 100644
index 0000000..f7f97f0
--- /dev/null
+++ b/0002-Revert-usb-quirks-Add-USB_QUIRK_RESET-for-Quectel-EG.patch
@@ -0,0 +1,28 @@
+From 9d662fb865ae496a7eb51d2bdddefd2427d9a30e Mon Sep 17 00:00:00 2001
+From: Bhushan Shah <bshah@kde.org>
+Date: Fri, 9 Apr 2021 16:25:25 +0530
+Subject: [PATCH 2/5] Revert "usb: quirks: Add USB_QUIRK_RESET for Quectel
+ EG25G Modem"
+
+Reverts 8cc2a406ecc711f5
+---
+ drivers/usb/core/quirks.c | 3 ---
+ 1 file changed, 3 deletions(-)
+
+diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c
+index cb556617aa34f..6ade3daf78584 100644
+--- a/drivers/usb/core/quirks.c
++++ b/drivers/usb/core/quirks.c
+@@ -501,9 +501,6 @@ static const struct usb_device_id usb_quirk_list[] = {
+ 	/* INTEL VALUE SSD */
+ 	{ USB_DEVICE(0x8086, 0xf1a5), .driver_info = USB_QUIRK_RESET_RESUME },
+ 
+-	/* Quectel EG25G Modem */
+-	{ USB_DEVICE(0x2c7c, 0x0125), .driver_info = USB_QUIRK_RESET },
+-
+ 	{ }  /* terminating entry must be last */
+ };
+ 
+-- 
+2.31.1
+
diff --git a/0003-qmi_wwan-provide-wrapper-for-reset_resume.patch b/0003-qmi_wwan-provide-wrapper-for-reset_resume.patch
new file mode 100644
index 0000000..ae9a456
--- /dev/null
+++ b/0003-qmi_wwan-provide-wrapper-for-reset_resume.patch
@@ -0,0 +1,51 @@
+From 562a6c114ce736db51e41b8c06c408104b79b126 Mon Sep 17 00:00:00 2001
+From: Bhushan Shah <bshah@kde.org>
+Date: Wed, 14 Apr 2021 10:29:39 +0530
+Subject: [PATCH 3/5] qmi_wwan: provide wrapper for reset_resume
+
+---
+ drivers/net/usb/qmi_wwan.c | 21 ++++++++++++++++++++-
+ 1 file changed, 20 insertions(+), 1 deletion(-)
+
+diff --git a/drivers/net/usb/qmi_wwan.c b/drivers/net/usb/qmi_wwan.c
+index e18ded349d840..cd6ae9696b56a 100644
+--- a/drivers/net/usb/qmi_wwan.c
++++ b/drivers/net/usb/qmi_wwan.c
+@@ -840,6 +840,25 @@ static int qmi_wwan_resume(struct usb_interface *intf)
+ 	return ret;
+ }
+ 
++static int qmi_wwan_reset_resume(struct usb_interface *intf)
++{
++	struct usbnet *dev = usb_get_intfdata(intf);
++	struct qmi_wwan_state *info = (void *)&dev->data;
++	int ret = 0;
++	bool callsub = (intf == info->control && info->subdriver &&
++			info->subdriver->reset_resume);
++
++	if (callsub)
++		ret = info->subdriver->reset_resume(intf);
++	if (ret < 0)
++		goto err;
++	ret = usbnet_resume(intf);
++	if (ret < 0 && callsub)
++		info->subdriver->suspend(intf, PMSG_SUSPEND);
++err:
++	return ret;
++}
++
+ static const struct driver_info	qmi_wwan_info = {
+ 	.description	= "WWAN/QMI device",
+ 	.flags		= FLAG_WWAN | FLAG_SEND_ZLP,
+@@ -1478,7 +1497,7 @@ static struct usb_driver qmi_wwan_driver = {
+ 	.disconnect	      = qmi_wwan_disconnect,
+ 	.suspend	      = qmi_wwan_suspend,
+ 	.resume		      =	qmi_wwan_resume,
+-	.reset_resume         = qmi_wwan_resume,
++	.reset_resume         = qmi_wwan_reset_resume,
+ 	.supports_autosuspend = 1,
+ 	.disable_hub_initiated_lpm = 1,
+ };
+-- 
+2.31.1
+
diff --git a/0004-cdc-wdm-provide-wrapper-for-reset_resume.patch b/0004-cdc-wdm-provide-wrapper-for-reset_resume.patch
new file mode 100644
index 0000000..50e3a3b
--- /dev/null
+++ b/0004-cdc-wdm-provide-wrapper-for-reset_resume.patch
@@ -0,0 +1,65 @@
+From 3af7a8b44f265a482c8297b420085cfb53725136 Mon Sep 17 00:00:00 2001
+From: Bhushan Shah <bshah@kde.org>
+Date: Wed, 14 Apr 2021 10:29:57 +0530
+Subject: [PATCH 4/5] cdc-wdm: provide wrapper for reset_resume
+
+---
+ drivers/usb/class/cdc-wdm.c | 35 ++++++++++++++++++++++++++++++++++-
+ 1 file changed, 34 insertions(+), 1 deletion(-)
+
+diff --git a/drivers/usb/class/cdc-wdm.c b/drivers/usb/class/cdc-wdm.c
+index 508b1c3f8b731..2b9355ed4a2ad 100644
+--- a/drivers/usb/class/cdc-wdm.c
++++ b/drivers/usb/class/cdc-wdm.c
+@@ -1119,6 +1119,39 @@ static int wdm_resume(struct usb_interface *intf)
+ 
+ 	return rv;
+ }
++
++static int wdm_reset_resume(struct usb_interface *intf)
++{
++	struct wdm_device *desc = wdm_find_device(intf);
++	int rv;
++
++	dev_dbg(&desc->intf->dev, "wdm%d_reset_resume\n", intf->minor);
++
++	spin_lock_irq(&desc->iuspin);
++	set_bit(WDM_RESETTING, &desc->flags);
++	set_bit(WDM_READ, &desc->flags);
++	clear_bit(WDM_IN_USE, &desc->flags);
++
++	desc->rerr = -EINTR;
++
++	spin_unlock_irq(&desc->iuspin);
++	wake_up_all(&desc->wait);
++	mutex_lock(&desc->rlock);
++	mutex_lock(&desc->wlock);
++	kill_urbs(desc);
++	cancel_work_sync(&desc->rxwork);
++	cancel_work_sync(&desc->service_outs_intr);
++
++	clear_bit(WDM_SUSPENDING, &desc->flags);
++	clear_bit(WDM_OVERFLOW, &desc->flags);
++	clear_bit(WDM_RESETTING, &desc->flags);
++
++	rv = recover_from_urb_loss(desc);
++	mutex_unlock(&desc->wlock);
++	mutex_unlock(&desc->rlock);
++
++	return rv;
++}
+ #endif
+ 
+ static int wdm_pre_reset(struct usb_interface *intf)
+@@ -1166,7 +1199,7 @@ static struct usb_driver wdm_driver = {
+ #ifdef CONFIG_PM
+ 	.suspend =	wdm_suspend,
+ 	.resume =	wdm_resume,
+-	.reset_resume =	wdm_resume,
++	.reset_resume =	wdm_reset_resume,
+ #endif
+ 	.pre_reset =	wdm_pre_reset,
+ 	.post_reset =	wdm_post_reset,
+-- 
+2.31.1
+
diff --git a/0005-net-usb-qmi_wwan-set-the-DTR-when-resuming.patch b/0005-net-usb-qmi_wwan-set-the-DTR-when-resuming.patch
new file mode 100644
index 0000000..6fe7e32
--- /dev/null
+++ b/0005-net-usb-qmi_wwan-set-the-DTR-when-resuming.patch
@@ -0,0 +1,34 @@
+From ed73c96e313c549f710df58c8fbe47200ee13df1 Mon Sep 17 00:00:00 2001
+From: Bhushan Shah <bshah@kde.org>
+Date: Sat, 10 Apr 2021 08:52:05 +0530
+Subject: [PATCH 5/5] net: usb: qmi_wwan: set the DTR when resuming
+
+If usb device does reset_resume instead of unbind/bind, we need to
+re-enable the DTR quirk, that way after resuming connection QMI
+communication between host and modem is possible again.
+
+Signed-off-by: Bhushan Shah <bshah@kde.org>
+Tested-by: Dalton Durst <d@ltondur.st>
+---
+ drivers/net/usb/qmi_wwan.c | 5 +++++
+ 1 file changed, 5 insertions(+)
+
+diff --git a/drivers/net/usb/qmi_wwan.c b/drivers/net/usb/qmi_wwan.c
+index cd6ae9696b56a..ada94a3242146 100644
+--- a/drivers/net/usb/qmi_wwan.c
++++ b/drivers/net/usb/qmi_wwan.c
+@@ -855,6 +855,11 @@ static int qmi_wwan_reset_resume(struct usb_interface *intf)
+ 	ret = usbnet_resume(intf);
+ 	if (ret < 0 && callsub)
+ 		info->subdriver->suspend(intf, PMSG_SUSPEND);
++
++	if (dev->driver_info->data & QMI_WWAN_QUIRK_DTR ||
++	    le16_to_cpu(dev->udev->descriptor.bcdUSB) >= 0x0201) {
++		qmi_wwan_change_dtr(dev, true);
++	}
+ err:
+ 	return ret;
+ }
+-- 
+2.31.1
+
diff --git a/0006-cdc-wdm-send-HUP-if-we-are-resetting.patch b/0006-cdc-wdm-send-HUP-if-we-are-resetting.patch
new file mode 100644
index 0000000..072bda0
--- /dev/null
+++ b/0006-cdc-wdm-send-HUP-if-we-are-resetting.patch
@@ -0,0 +1,27 @@
+From 1671ef2de0f3f698622bed7ba0e9a605fdd260fc Mon Sep 17 00:00:00 2001
+From: Bhushan Shah <bshah@kde.org>
+Date: Wed, 14 Apr 2021 18:58:41 +0530
+Subject: [PATCH 6/6] cdc-wdm: send HUP if we are resetting
+
+If userspace is polling the cdc-wdm socket, and device resets then we
+should notify userspace/client about reset.
+---
+ drivers/usb/class/cdc-wdm.c | 2 ++
+ 1 file changed, 2 insertions(+)
+
+diff --git a/drivers/usb/class/cdc-wdm.c b/drivers/usb/class/cdc-wdm.c
+index 2b9355ed4a2ad..93d9bacc18384 100644
+--- a/drivers/usb/class/cdc-wdm.c
++++ b/drivers/usb/class/cdc-wdm.c
+@@ -666,6 +666,8 @@ static __poll_t wdm_poll(struct file *file, struct poll_table_struct *wait)
+ 		spin_unlock_irqrestore(&desc->iuspin, flags);
+ 		goto desc_out;
+ 	}
++	if (test_bit(WDM_RESETTING, &desc->flags))
++		mask = EPOLLHUP;
+ 	if (test_bit(WDM_READ, &desc->flags))
+ 		mask = EPOLLIN | EPOLLRDNORM;
+ 	if (desc->rerr || desc->werr)
+-- 
+2.31.1
+
-- 
GitLab

